@startuml
' Project Workflow Diagram for product-lookup-rag
' Shows ingestion, embedding, storage into Neo4j, GDS detection, retrieval pathways,
' agent orchestration and Docker build/cache

skin rose

actor Developer
participant "scripts/ingest.py" as Ingest
participant "scripts/setup_embeddings.py" as SetupEmbeddings
participant "OpenAI Embedding API" as OpenAI
participant "Neo4j DB" as Neo4j
participant "App: graph.get_graph()" as Graph
participant "App: retrieval.py" as Retrieval
participant "App: agent.py" as Agent
participant "FastAPI (app.main)" as API
participant "Client (curl / UI)" as Client
participant "Docker Build" as Docker

== Ingest & Embeddings ==
Developer -> Ingest: run ingest.py (source data -> nodes/relationships)
Ingest -> Neo4j: CREATE/MERGE Product nodes + properties
note right: deterministic IDs/parameters used

Developer -> SetupEmbeddings: run setup_embeddings.py (--dry-run optional)
SetupEmbeddings -> Neo4j: query product content to embed
SetupEmbeddings -> OpenAI: request embeddings (text-embedding-3-small)
OpenAI --> SetupEmbeddings: embedding vectors
SetupEmbeddings -> Neo4j: SET p.embedding = [float,...]
note right: idempotent via content hash; checks existing dims

== App Startup / Graph Connection ==
Docker -> Graph: start app in container (reads .env)
Graph -> Neo4j: connect using NEO4J_URL/USER/PASS/DB
Graph --> Neo4j: If DB not reachable, try alternate DB names
Graph -> Graph: cached connection returned

== GDS / Similarity Detection ==
Retrieval -> Neo4j: test for server-side similarity functions
Retrieval -> Neo4j: RETURN gds.similarity.cosine([0.1],[0.1])
Neo4j --> Retrieval: success or exception
alt gds available
    Retrieval -> Retrieval: set server_similarity_fn = "gds.similarity.cosine"
    Retrieval -> Retrieval: note "will attempt server-side GDS similarity queries"
else fallback
    Retrieval -> Retrieval: server_similarity_fn = None
    Retrieval -> Retrieval: plan client-side numpy cosine
    Retrieval -> Retrieval: note "will use in-process numpy fallback"
end

== Retrieval Flow (Query by Entities) ==
Client -> API: POST /query {entities, product, prompt}
API -> Agent: optional agent run or direct Retrieval.query_by_entities
Retrieval -> Neo4j: Deterministic exact-match on entity values (first)
note right: builds parameterized Cypher: MATCH (p:Product) -[:REL]->(E:Entity) WHERE toLower(E.value)=toLower($Value)
alt exact-match found
    Neo4j --> Retrieval: rows (return as entities_exact_match)
    Retrieval -> API: return rows to Client
else no exact-match
    alt server-side-similarity-configured
        Retrieval -> Neo4j: PREPARE projection (gds.graph.project or similar)
        Neo4j --> Retrieval: projection created / already exists
        Retrieval -> Neo4j: CALL gds.similarity.cosine.stream(projectName, {nodeProjection:'Product', relationshipProjection:{}}) YIELD node1, node2, similarity
        Neo4j --> Retrieval: raw similarity stream
        Retrieval -> Retrieval: transform stream to top-k results, attach retrieval_method
        Retrieval -> API: return similarity results with retrieval_method metadata
    else server-side not available or failed
        Retrieval -> Neo4j: MATCH (p:Product) WHERE p.embedding IS NOT NULL RETURN p.id AS id, p.embedding AS emb
        Neo4j --> Retrieval: rows with embeddings
        Retrieval -> Retrieval: build query vector from prompt or combined entity text
        Retrieval -> Retrieval: compute cosine similarities in-process (numpy)
        Retrieval -> Retrieval: filter by similarity_threshold and select top_k
        Retrieval -> API: return client-side similarity results with retrieval_method metadata
    end
end

== Agent / Tool Orchestration ==
Client -> API: POST /agent/structured (user prompt)
API -> Agent: agent_run_structured (temperature=0)
Agent -> Retrieval: call Query tool or Similarity tool
Agent -> Agent: logs which tool used, includes retrieval_method in result
Agent -> API: compose final answer + cited products
API -> Client: structured JSON with tool provenance

== Debugging & Maintenance Endpoints ==
Client -> API: GET /debug/cypher?q=... (run arbitrary cypher for debugging)
API -> Neo4j: executes and returns raw rows (admin only)

== Docker Build & Caching ==
Developer -> Docker: docker build (use BuildKit)
Docker -> Docker: COPY environment.yml, requirements.txt first
Docker -> Docker: create conda/micromamba env
note right: use cache mounts for conda pkgs and pip
Docker -> Docker: COPY rest of source (invalidates later)
Docker -> Docker: set CMD uvicorn app.main:app

== Failure Modes & Fallbacks ==
note over Retrieval, Neo4j
- Missing embeddings -> SetupEmbeddings should populate
- Wrong embedding dim -> log + skip vector ops
- GDS function not present -> client-side fallback
- Docker container can't reach Neo4j -> check host.docker.internal or network
end note

@enduml
